import{s as Y,b as G,e as E,n as K}from"../chunks/CRYARyhg.js";import{S as Q,i as ee,c as R,a as V,m as z,t as D,e as W,g as j,h as d,s as p,j as h,n as c,b as u,l as te,d as i,f as a}from"../chunks/BwxSQcIe.js";import{g as se,a as F}from"../chunks/CgU5AtxT.js";import{B as ne}from"../chunks/r0TscNb7.js";import{R as ie}from"../chunks/Cdp-jO_w.js";import{C as ae}from"../chunks/C4QtfuXn.js";function oe($){let t,f="<b>Thomas Dooms*</b>, Ward Gauderis*, Geraint Wiggins, Jose M. Oramas",l,o,n="",r,m,T,g,N="Overview",k,v,U=`Previous work in weight-based interpretability was limited to single layer analysis.
To interpret deeper models, sparse dictionary learning was necessary divide into subproblems.
Ideally, we would want to extract features, purely from the weights, even in deeper models.`,H,w,J=`This paper introduces a theoretic framework toward scalable weight-based interpretability.
These insights are used toward a new algorithm that globally decomposes the weights of a model, akin to SVD.
While this algorithm optimises toward rank, it naturally finds sparse structure, which is easy to understand.`,M,_,O=`This decomposition can be used to find the globally most important eigenvectors for each output class.
we study a multi-layer image model trained on the SVHN dataset (a more challenging variant of MNIST that single layer models can’t solve).`,I,x,X='<img src="/research/xnet/digits.png" alt="Top SVHN eigenvectors." width="500px"/> <figcaption>Top eigenvectors (extracted from the weights) per class of a 3-layer SVHN classifier.</figcaption>',L,y,Z=`The decomposition can also be used to morph the model into a sparse compositional tree.
The bottom row of this figure shows the most important ‘features’ to the model.
These reveal important strokes or proto-digits, hinting the model has learned sensible structure.
The next layers represent ‘interaction matrices’, which describe how features interact.
The first two layers only combine a handful of features together.
The last layer densely (but still low-rank) combines these composed features into a prediction.
Tracing out paths through this tree shows how the model forms specific predictions.`,S,b,B='<img src="/research/xnet/cores.png" alt="Sparse weights of the same model." width="500px"/> <figcaption>Visualisations of the weights after a global decomposition.</figcaption>',P,C,A;return m=new ie({props:{paper:"https://openreview.net/pdf?id=bXAt5iZ69l",video:"https://www.youtube.com/watch?v=yUGZVPJlvzY"}}),C=new ae({props:{text:`@inproceedings{
    dooms2025compositionality,
    title={Compositionality Unlocks Deep Interpretable Models},
    author={Thomas Dooms and Ward Gauderis and Geraint Wiggins and Jose Oramas},
    booktitle={Submitted to AAAI'25 workshop on CoLoRAI - Connecting Low-Rank Representations in AI},
    year={2025},
    url={https://openreview.net/forum?id=bXAt5iZ69l},
    note={under review}
}`}}),{c(){t=d("p"),t.innerHTML=f,l=p(),o=d("div"),o.innerHTML=n,r=p(),R(m.$$.fragment),T=p(),g=d("h3"),g.textContent=N,k=p(),v=d("p"),v.textContent=U,H=p(),w=d("p"),w.textContent=J,M=p(),_=d("p"),_.textContent=O,I=p(),x=d("figure"),x.innerHTML=X,L=p(),y=d("p"),y.textContent=Z,S=p(),b=d("figure"),b.innerHTML=B,P=p(),R(C.$$.fragment),this.h()},l(e){t=h(e,"P",{"data-svelte-h":!0}),c(t)!=="svelte-sa4z7o"&&(t.innerHTML=f),l=u(e),o=h(e,"DIV",{class:!0,"data-svelte-h":!0}),c(o)!=="svelte-wdfy0z"&&(o.innerHTML=n),r=u(e),V(m.$$.fragment,e),T=u(e),g=h(e,"H3",{"data-svelte-h":!0}),c(g)!=="svelte-1diyj43"&&(g.textContent=N),k=u(e),v=h(e,"P",{"data-svelte-h":!0}),c(v)!=="svelte-12uwyiu"&&(v.textContent=U),H=u(e),w=h(e,"P",{"data-svelte-h":!0}),c(w)!=="svelte-11b4rjk"&&(w.textContent=J),M=u(e),_=h(e,"P",{"data-svelte-h":!0}),c(_)!=="svelte-2plgvz"&&(_.textContent=O),I=u(e),x=h(e,"FIGURE",{"data-svelte-h":!0}),c(x)!=="svelte-1tvmy4u"&&(x.innerHTML=X),L=u(e),y=h(e,"P",{"data-svelte-h":!0}),c(y)!=="svelte-15l15yz"&&(y.textContent=Z),S=u(e),b=h(e,"FIGURE",{"data-svelte-h":!0}),c(b)!=="svelte-12xpoh4"&&(b.innerHTML=B),P=u(e),V(C.$$.fragment,e),this.h()},h(){te(o,"class","mt-6")},m(e,s){i(e,t,s),i(e,l,s),i(e,o,s),i(e,r,s),z(m,e,s),i(e,T,s),i(e,g,s),i(e,k,s),i(e,v,s),i(e,H,s),i(e,w,s),i(e,M,s),i(e,_,s),i(e,I,s),i(e,x,s),i(e,L,s),i(e,y,s),i(e,S,s),i(e,b,s),i(e,P,s),z(C,e,s),A=!0},p:K,i(e){A||(D(m.$$.fragment,e),D(C.$$.fragment,e),A=!0)},o(e){W(m.$$.fragment,e),W(C.$$.fragment,e),A=!1},d(e){e&&(a(t),a(l),a(o),a(r),a(T),a(g),a(k),a(v),a(H),a(w),a(M),a(_),a(I),a(x),a(L),a(y),a(S),a(b),a(P)),j(m,e),j(C,e)}}}function re($){let t,f;const l=[$[0],q];let o={$$slots:{default:[oe]},$$scope:{ctx:$}};for(let n=0;n<l.length;n+=1)o=G(o,l[n]);return t=new ne({props:o}),{c(){R(t.$$.fragment)},l(n){V(t.$$.fragment,n)},m(n,r){z(t,n,r),f=!0},p(n,[r]){const m=r&1?se(l,[r&1&&F(n[0]),r&0&&F(q)]):{};r&2&&(m.$$scope={dirty:r,ctx:n}),t.$set(m)},i(n){f||(D(t.$$.fragment,n),f=!0)},o(n){W(t.$$.fragment,n),f=!1},d(n){j(t,n)}}}const q={title:"Introducing X-nets",date:"12 Mar 2024",kind:"research"};function le($,t,f){return $.$$set=l=>{f(0,t=G(G({},t),E(l)))},t=E(t),[t]}class ce extends Q{constructor(t){super(),ee(this,t,le,re,Y,{})}}export{ce as component};
