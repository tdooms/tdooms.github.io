<!DOCTYPE html><meta charset="utf-8"/><p>I have been actively nerd-sniping recruits to the cult of tensor networks.
While this has been great, I keep promising greatness without backing that up. This post provides an introductory overview of the topic for the newly initiated. This post is aimed at interpretability researchers.</p>
<p>While the central concept behind tensor networks is not very difficult, the literature can be daunting. In contrast, this post is vibe-written, distilling the main ideas succinctly and (hopefully) clearly. Do not expect rigour (or even correctness).</p>
<p>This tutorial offers a range of references, along with some preliminary explanations and intuition, to help get started with a specific set of papers. The final goal is for this to become a self-contained booklet.
However, apparently, distilling a deeply technical field into bite-sized concepts is challenging.</p>
<p>This tutorial contains four parts.</p>
<ul>
<li>What are tensor networks?</li>
<li>Tensor networks generalise decompositions.</li>
<li>Cool algorithms for tensor networks.</li>
<li>Generalising ‘structure’ with tensor networks.</li>
</ul>
<h2 id="what-are-tensor-networks">What are tensor networks?</h2>
<p>Tensors are generalisations of matrices that describe complex interactions between an arbitrary number of sources, often referred to as modes. In contrast, matrices define linear relations between two modes, but tensors allow arbitrarily many.
The drawback is that most tensors are intractable to store.
Assuming sources are of equal dimensionality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span>, a matrix contains <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> entries, but tensors require <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">n^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span> entries depending on the number of sources <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">s</span></span></span></span>.</p>
<p>Consequently, tensors are generally never instantiated but rather defined in a compact manner using tensor networks. Tensor networks are graphs where the edges are contractions, and the nodes are tensors. Notably, tensor networks can (and should!) be denoted diagrammatically, which is genuinely extremely helpful. These diagrams allow one to reason about complex structures in a visual manner (and doodle while in the shower).</p>
<p>Unfortunately, I don’t think a proper introductory resource exists yet.
I have a <a href="https://compinterp.github.io/assets/book/intro/networks.html">self-written (but incomplete) source</a> about tensor diagrams.
The following are (seen as) the defaults to learn about <a href="https://tensornetwork.org/">tensor</a> <a href="https://www.tensors.net/tutorials">networks</a>.
There is also an <a href="https://arxiv.org/pdf/2402.01790v1">interpretability specific introduction</a>. Unfortunately, I think that article doesn’t put sufficient emphasis on structure and algorithms.</p>
<blockquote>
<p>You’ll see a stark contrast between papers that use proper diagrammatic notation and others that use old-school Einstein notation. I find the latter impossible to comprehend, even with extensive experience.</p>
</blockquote>
<h2 id="tensor-networks-generalise-decompositions">Tensor networks generalise decompositions</h2>
<p>Tensor networks describe <em>structured</em> tensors, which equates to some form of decomposition. Matrix decompositions typically consist of only two or three structured parts — hardly a “network”. But, as we will see, tensors can be meaningfully described by arbitrarily complex networks.</p>
<p>We focus on two reasonable and straightforward tensor decompositions which generalise across orders: the canonical polyadic decomposition (CPD) and the Tucker decomposition (TD).</p>
<blockquote>
<p>The CPD is known under many names, such as Candecomp/Parafac decomposition or tensor rank decomposition. This will be a recurring theme throughout; try to ignore this unfortunate confusion.</p>
</blockquote>
<p>In short, the CPD is a sum of rank-1 outer products, which resembles the singular value decomposition (SVD) but with an outer product of three vectors. The CPD splits an order <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span> tensor into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span> matrices with an outer product operation in the middle. Interestingly, a SwiGLU is precisely a CPD if you remove the Swish non-linearity. It describes how two inputs interact towards an output, making it an <a href="https://arxiv.org/abs/2410.08417">interesting object of study</a>.</p>
<p>It’s generally accepted that this is the most meaningful generalisation of rank to arbitrary tensors. Unfortunately, computing this is NP-hard in general, and there are almost no meaningful bounds to reason about this rank. However, it’s known tensor rank saturates at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>min</mi><mo>⁡</mo></mrow><mi>j</mi></msub><mo stretchy="false">(</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><mi>k</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min_j(\prod^{k}_{i \neq j} n_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4248em;vertical-align:-0.4358em"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.989em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="rlap mtight"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="inner"><span class="mord mtight"><span class="mrel mtight"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> (lowest product of all mode dimensions except one), just like matrix rank saturates at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min(n, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> (where n and m are the dimensions, which is just a special case of the tensor formula).</p>
<blockquote>
<p>This is quite useful because you can quantify how much ‘signal’ the tensor network is capturing instead of just populating the whole product space.</p>
</blockquote>
<p>The TD comprises a down-projection for each mode, combined with a tensor ‘core’ that contains the higher-order interactions, albeit in a compressed format. See <a href="https://www.kolda.net/publication/TensorReview.pdf">this seminal (albeit old) paper</a> for more details/rigour.</p>
<ul>
<li>The CPD represents a sum of simple interactions-&gt; simple computation but in high dimensions.</li>
<li>The TD compresses its higher-order interactions-&gt; complex computation but in lower dimensions.</li>
</ul>
<p>You may wonder if there’s something in between, and the answer is yes!
Let’s generalise a bit; there are two variables to this (this has a bunch of official names, so I’m going to use what makes the most sense to me).</p>
<ul>
<li>The factor dimension is 1 for a CPD and high for a TD. I refer to this as the complexity of interactions/computations.</li>
<li>The factor amount is high for a CPD but 1 for a TD. This intuitively means the amount of ‘distinct’ interactions.</li>
</ul>
<p>From this viewpoint, it could make sense to trade off the amount of factors for a higher dimension for each. For instance, what if you changed the CPD such that each factor is dimension 2. Or, put differently, a sum of small TDs. This topic has been previously studied and lies at a fascinating intersection of <a href="https://tensorlab.net/doc/ll1.html">compressed sensing and tensor networks</a>.</p>
<p>The trade-off is helpful because if the underlying computation requires interactions of rank 2, it will take many CPD (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span></span></span></span></span></span></span></span>, I think) factors to represent this. So, finding these ‘joint’ factors is a good way to compress the computation/interactions. The notion of structure in tensor networks its geometric interpretation is formalised in the last section. In short, any form of structure, either through manifolds, bottlenecks, or (communication) flow constraints, is describable by this.</p>
<p>Before that, though, I want to talk about <strong>really</strong> high-order tensor networks. While it becomes harder to reason about, it’s not uncommon to want to describe interactions between thousands of sources. Here, the TD completely fails, even for factor dimension 2. The CPD is probably still storable but requires way too many parameters.</p>
<p>Enter <a href="https://publications.rwth-aachen.de/record/674222/files/674222.pdf">hierarchical formats</a>. Instead of defining a decomposition between all modes, we can introduce ‘hidden modes’. You can form a tensor tree where each decomposition only combines a few modes at a time in the form of a tree. This is known as an H(ierarchical)-Tucker decomposition. It’s also possible to use the CPD to describe intermediate interactions, although I have thus far failed to find a literature reference that studies this specific network class. In any case, this idea is often abstracted as “tree tensor networks”, where only a single path connects each mode. These are generally really nice to work with and have a variety of algorithms that work on them.</p>
<p><img src="/blogs/carsales.jpg" alt="image"/></p>
<p>There exist specific decompositions (MERA/PEPS) that are not trees (they contain so-called loops) but still have many valuable properties. We do not discuss them here.</p>
<p>This marks the end of the tensor network whirlwind tour. These networks transparently encode interactions in a way that is easy to reason about while being extremely expressive.</p>
<h2 id="cool-algorithms-for-tensor-networks">Cool algorithms for tensor networks</h2>
<p>Due to the generality of tensor networks, it’s possible to imagine arbitrarily complex algorithms. Luckily, many of them boil down to one core algorithm: diagonalisation. Diagonalisation extends the idea of matrix diagonalisation but operates on the connections of tensors. This enables one to assign a singular value to each dimension of the connection and potentially enables pruning really big parts of the network. This algorithm is also sometimes called canonicalisation because it reveals the most compressed and natural form of a tensor network.</p>
<p>In short, for each connection/edge/wire, we view both sides as two huge matrices, for which we compute the left and right singular values. Computing the singular values can be done extremely efficiently (for reasons that I don’t think I can explain in simple terms).</p>
<blockquote>
<p>Even though this algorithm assumes a tree tensor network (such that both sides are disconnected), you can still perform this to get meaningful results in arbitrary networks.</p>
</blockquote>
<p>I’ve only found one paper that is <a href="https://arxiv.org/pdf/1801.05390">somewhat accessible</a> on the topic.
Then there are two papers, describing <a href="https://arxiv.org/pdf/1705.00880">theory</a> and <a href="https://arxiv.org/pdf/1811.04455">algorithms</a> which are insightful but basically impossible to understand by mere mortals.
I tried writing <a href="https://arxiv.org/pdf/2504.02667">a paper</a> to distill these ideas, but it’s still a bit hard to grasp probably.</p>
<h2 id="generalising-structure-with-tensor-networks">Generalising ‘structure’ with tensor networks</h2>
<p>As said in a previous chapter, some tensor networks allow trading factor count for factor size. There, we provided an example of enhancing the CPD to have factors of size 2. Here, I explain how structure in the factor matrices influences the representable interactions.</p>
<p>One can rephrase the CPD of factor size 2 as a CPD of twice the hidden dimension, but where each factor matrix is constrained by a 2-block diagonal matrix (forcing rows/columns to be joint). This can be extended to sparsity; if the factor matrices admit a sparse decomposition, then this bounds the interactions into (small) groups of arbitrary size. See <a href="https://tensorlab.net/doc/cpd.html">this website</a> and <a href="https://lirias.kuleuven.be/retrieve/646609">this paper</a>.</p>
<p>Tensor networks enable the definition of high-level interaction topologies, while structured matrices facilitate the definition of low-level interactions. Both are extremely meaningful in their own right and extremely useful to find any form of ‘structure’. Importantly, the interpretation of low-level structure is dependent on the higher-level structure and may lose meaning when complex non-linearities are introduced.</p>
<p>Especially sparsity is cool because, if sufficiently low (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">&lt;3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">3</span></span></span></span>), it explains visualisable geometries. Since tensor networks can represent polynomials (interactions with oneself), suddenly, sparsity on a CPD implies low-degree polynomial manifolds like conic sections and circles!</p>
<p>Let me handwave my way through other forms of structure. For instance, ‘flow restriction’, where a given element can only interact with prior elements to enforce a specific order, is simply adding an upper or lower triangular matrix anywhere in the tensor network. Alternatively, matrices themselves can be represented as tensor networks, which constrain their representations in even more complicated (but potentially useful) ways, eg. <a href="https://arxiv.org/abs/2204.00595">Monarch matrices</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this introduction has provided sufficient motivation behind tensor networks.
The objects genuinely have a bunch of nice properties, not just in terms of expressiveness, but only on how to reason about them.
Unfortunately, this knowledge is often hidden behind opaque theorems and inscrutable papers.
My hope is to distill this knowledge toward practical use-cases, especially in interpretability.</p>